datasetid = datasetid,
dataTable = table_99013
)
source("00_batch/batch_xml.R")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("00_batch/batch_xml.R")
getwd()
source("../00_batch/batch_xml.R")
source("./00_batch/batch_xml.R")
source("../00_batch/batch_xml.R")
getwd()
# loading all the packages
source("00_EMLmbon/posgre.r")
View(creator_test3)
View(creator_test2)
creator_test2[[8]][[6]]
create_EML <-
function(meta_list,
dataset_id,
data_table,
other_entity = NULL
) {
project <- subset(meta_list[["dataset"]], datasetid == dataset_id)
# -----------------------------------------------------------------------------
# creator
creator_list <-
subset(meta_list[["creator"]],
datasetid == dataset_id & authorshiprole == "creator")
# function to create a creator object
create_creator <- function(creator) {
given_name <-
trimws(paste(creator[['givenname']],
replace(creator[['givenname2']], is.na(creator[['givenname2']]), ""),
" "))
p <- list(
individualName = list(givenName = given_name,
surName = creator[['surname']]),
organizationName = creator[['organization']],
address = list(
deliveryPoint = trimws(paste(
creator[['address1']],
replace(creator[['address2']], is.na(creator[['address2']]), ""),
replace(creator[['address3']], is.na(creator[['address3']]), ""),
" "
)),
city = creator[['city']],
administrativeArea = creator[['state']],
postalCode = creator[['zipcode']],
country = creator[['country']]
),
phone = creator[['phone1']],
electronicaMailAddress = if (is.na(creator[['email']]))
NULL
else
creator[['email']],
userId = if (!is.na(creator[['orcid']]))
list(system = paste0("https://orcid.org/", creator[['orcid']]))
else
NULL
)
return(p)
}
personnel <- apply(creator_list, 1, create_creator)
# -------------------------------------------------------------------------------
# methods
method <- subset(meta_list[['method']], datasetid == dataset_id)
methodnum <- unique(method$methodDocument)
for (ii in 1:length(methodnum)) {
method_s <- subset(method, method$methodDocument == methodnum[ii])
software <- if (is.na(method_s$softwareDescription[1])) {
NULL
} else {
list(
title = if (is.na(method_s$softwareTitle)[1]) {
NULL
} else {
method_s$softwareTitle[1]
},
creator = if (is.na(method_s$softwareOwner[1])) {
NULL
} else {
list(individualName = list(surName = method_s$softwareOwner[1]))
},
implementation = list(distribution = list(online = list(
url = list(
method_s$softwareDescription[1],
"function" = new("xml_attribute", "download")
)
))),
version = method_s$softwareVersion[1]
)
}
instrument <- if (is.na(method_s$instrumentDescription[1])) {
NULL
} else {
list(
title = if (is.na(method_s$instrumentTitle[1])) {
NULL
} else {
method_s$instrumentTitle[1]
},
creator = if (is.na(method_s$instrumentOwner[1])) {
NULL
} else {
list(individualName = list(surName = method_s$instrumentOwner[1]))
},
distribution = list(online = list(
url = list(
method_s$instrumentDescription[1],
"function" = new("xml_attribute", "download")
)
))
)
}
if (!is.na(method_s$protocolDescription)) {
for (kk in 1:nrow(method_s)) {
protocol <- if (is.na(method_s$protocolDescription[kk])) {
NULL
} else {
list(
title = if (is.na(method_s$protocolTitle[kk])) {
NULL
} else {
method_s$protocolTitle[kk]
},
creator = if (is.na(method_s$protocolOwner[kk])) {
NULL
} else {
list(individualName = list(surName = method_s$protocolOwner[kk]))
},
distribution = list(online = list(
url = list(
method_s$protocolDescription[kk],
"function" = new("xml_attribute", "download")
)
))
)
}
if (kk == 1) {
protocolall <- list(protocol)
} else {
protocolall <- c(protocolall, list(protocol))
}
}
} else {
protocolall <- NULL
}
methodstep <-
list(
description = as(set_TextType(methodnum[ii]), "description"),
instrumentation = instrument,
software = software,
protocol = protocolall
)
if (ii == 1) {
methodall <- list(methodstep)
} else {
methodall <- c(methodall, list(methodstep))
}
}
method_xml <- list(methodStep = methodall)
# ------------------------------------------------------------------------------
# abstract
abstract <- as(set_TextType(project$abstract), "abstract")
# ------------------------------------------------------------------------------
# temporal coverage
tempo <- subset(meta_list[["temporal"]], datasetid == dataset_id)
tempcover <- list(rangeOfDates =
list(
beginDate =
list(calendarDate = as.character(tempo[, "begindate"])),
endDate =
list(calendarDate = as.character(tempo[, "enddate"]))
))
# -----------------------------------------------------------------------------
# spatial coverage
geo <- subset(meta_list[["geo"]], datasetid == dataset_id)
geo_func <- function(geo_list){
geo <- list(geographicDescription = geo_list[['geographicdescription']],
boundingCoordinates = list(westBoundingCoordinate = as.character(geo_list[['westboundingcoordinate']]),
eastBoundingCoordinate = as.character(geo_list[['eastboundingcoordinate']]),
northBoundingCoordinate = as.character(geo_list[['northboundingcoordinate']]),
southBoundingCoordinate = as.character(geo_list[['southboundingcoordinate']])))
return(geo)
}
geoall <- apply(geo, 1, geo_func)
# -----------------------------------------------------------------------------
# overall coverage
coverage <- list(geographicCoverage = geoall,
temporalCoverage = tempcover)
# -----------------------------------------------------------------------------
# keywords
keywords <- subset(meta_list[['keyword']], datasetid == dataset_id)
#nkey <- unique(keyword$keyword_thesaurus)
key_func <- function(keyword_list){
k <- list(keyword = keyword_list[['keyword']],
keywordThesaurus = if (keyword_list[['keyword_thesaurus']] == 'none') NULL else keyword_list[['keyword_thesaurus']])
return(k)
}
kall <- apply(keywords, 1, key_func)
# -----------------------------------------------------------------------------
# boilerplate information
boilerplate <- read_eml("../00_Shared_document/boilerplate.xml")
access <- eml_get(boilerplate@access)
contact <- eml_get(boilerplate@dataset, element = "contact")
distribution <- eml_get(boilerplate@dataset, element = "distribution")
publisher <- eml_get(boilerplate@dataset, element = "publisher")
project_xml <- eml_get(boilerplate@dataset, element = "project")
license <-
as(set_TextType("../00_Shared_document/IntellectualRights.docx"), "intellectualRights")
# -----------------------------------------------------------------------------
# put the dataset together
dataset <- list(
title = project[['title']],
alternateIdentifier = project[['alternateid']],
shortname = project[['shortname']],
creator = personnel,
pubDate = as.character(as.Date(project[['pubdate']])),
intellectualRights = license,
abstract = abstract,
keywordSet = kall,
coverage = coverage,
contact = contact,
publisher = publisher,
distribution = distribution,
project = project_xml,
methods = method_xml,
language = "English",
dataTable = data_table,
otherEntity = other_entity
)
# -------------------------------------------------------------------------------------
# units
unit <- subset(meta_list[['unit']], datasetid == dataset_id)
# ------------------------------------------------------------------------------------
# EML EML EML EML
eml <- list(
packageId = project[['edinum']],
system = "knb",
schemaLocation = "eml://ecoinformatics.org/eml-2.1.1 http://nis.lternet.edu/schemas/EML/eml-2.1.1/eml.xsd",
access = access,
dataset = dataset,
if (dim(unit)[1] > 0){
additionalMetadata = as(set_unitList(unit), "additionalMetadata")
}
)
return(eml)
}
creator_test4 <- create_EML(entity_meta, 99013, table_99013, NULL)
View(creator_test4)
creator_test4[[6]]
write_eml(creator_test4, "EML_99013.xml")
write_eml(creator_test4, "EML_99013.xml")
write_eml(creator_test4, "EML_99013_2.xml")
?write_eml
eml_validate(creator_test4)
class(creator_test4)
devtools::install_github("ropensci/eml")
install.packages("devtools")
devtools::install_github("ropensci/eml")
devtools::install_github("ropensci/eml")
devtools::install_github("ropensci/eml")
install.packages("glue")
devtools::install_github("ropensci/eml")
devtools
devtools::install_github("ropensci/eml")
remove.packages("EML")
devtools::install_github("ropensci/eml")
devtools::install_github("ropensci/eml")
devtools::install_github("ropensci/eml")
install.packages("Rcpp")
devtools::install_github("ropensci/eml")
devtools::install_github("ropensci/eml")
packrat::status()
packrat::clean()
devtools::install_github("ropensci/eml")
devtools::install_github("ropensci/eml")
install.packages("devtools")
devtools::install_github("ropensci/eml")
install.packages("tibble")
devtools::install_github("ropensci/eml")
devtools::install_github("ropensci/eml")
# connect to metabase and get metadata from specified datasets
entity_meta <- get_meta(dbname = "lter_arranged", host = "localhost", port = 5432, c(99013, 99021))
# connect to metabase and query for metadata
# return a list of dfs
get_meta <- function(dbname, host, port, dataset_ids) {
# set DB driver
library(RPostgres)
driver <- RPostgres::Postgres()
# connect to specified DB
con <- dbConnect(
driver,
dbname = "lter_arranged",
host = host,
port = 5432,
user = rstudioapi::showPrompt(title = "Enter database username", message = "Username"),
password = rstudioapi::askForPassword(prompt = "Enter database password")
)
# views to query from
view_list <- list(
"mb2eml_r.vw_eml_attributes",
"mb2eml_r.vw_eml_attributecodedefinition",
"mb2eml_r.vw_custom_units",
"mb2eml_r.vw_eml_creator",
"mb2eml_r.vw_eml_keyword",
"mb2eml_r.vw_eml_entities",
"mb2eml_r.vw_eml_dataset",
"mb2eml_r.vw_eml_datasetmethod",
"mb2eml_r.vw_eml_geographiccoverage",
"mb2eml_r.vw_eml_temporalcoverage"
)
# create queries
queries <- paste("SELECT * FROM", view_list, "WHERE datasetid = $1")
# parameterize queries to prevent SQL injection
param_query <- function(query){
result <- dbSendQuery(conn = con, query)
dbBind(result, list(dataset_ids))
query_df <- dbFetch(result)
dbClearResult(result)
return(query_df)
}
# apply over list of queries and name list items
query_dfs <- lapply(queries, param_query)
names(query_dfs) <- c("meta", "factors", "unit", "creator", "keyword", "entities", "dataset", "method", "geo", "temporal")
return(query_dfs)
}
# create either a dataTable or an otherEntity custom class object
# for use in the custom function dataset()
create_entity <- function(meta_list, dataset_id, entity) {
# subset tables that are entity-specific
#specific <- meta_list[c("meta", "factors", "entities")]
#info <- lapply(specific, subset,datasetid == dataset_id & entity_position == entity)
ent <- subset(meta_list[["entities"]], datasetid == dataset_id & entity_position == entity)
fact1 <- subset(meta_list[["factors"]], datasetid == dataset_id & entity_position == entity)
meta1 <- subset(meta_list[["meta"]], datasetid == dataset_id & entity_position == entity)
filename <- ent$filename
size0 <- as.character(file.size(filename))
checksum <- digest::digest(filename, algo = "md5", file = TRUE)
if (ent$entitytype == "dataTable") {
## set_physical() is a method from `eml` package
physical <- set_physical(
objectName = filename,
size = size0,
sizeUnit = "byte",
url = paste0(ent$urlpath, filename),
numHeaderLines = if (is.na(ent$headerlines))
(NULL)
else
(as.character(ent$headerlines))
,
recordDelimiter = if (is.na(ent$recorddelimiter))
(NULL)
else
(ent$recorddelimiter)
,
fieldDelimiter = if (is.na(ent$fielddlimiter))
(NULL)
else
(ent$fielddlimiter)
,
quoteCharacter = if (is.na(ent$quotecharacter))
(NULL)
else
(ent$quotecharacter)
,
attributeOrientation = "column",
authentication = checksum,
authMethod = "MD5"
)
row <- nrow(fread(filename, data.table = F, showProgress = F))
if (dim(fact1)[1] > 0) {
attributeList <- set_attributes(meta1, factors = fact1)
} else {
attributeList <- set_attributes(meta1)
}
# assemble dataTable
dataTable <- list(
entityName = ent$entityname,
entityDescription = ent$entitydescription,
physical = physical,
attributeList = attributeList,
numberOfRecords = as.character(row)
)
} else {
physical <- list(
objectName = filename,
size = list(size0, unit = "byte"),
authentication = list(checksum, method = "MD5"),
dataFormat = list(externallyDefinedFormat = list(formatName = ent$formatname)),
distribution = list(online = list(url = list(paste0(ent$urlpath, filename),
"function" = list("download"))
))
)
dataTable <- list(
entityName = ent$entityname,
entityDescription = ent$entitydescription,
physical = physical,
entityType = ent$entitytype
)
}
return(dataTable)
}
# connect to metabase and get metadata from specified datasets
entity_meta <- get_meta(dbname = "lter_arranged", host = "localhost", port = 5432, c(99013, 99021))
# connect to metabase and get metadata from specified datasets
entity_meta <- get_meta(dbname = "lter_arranged", host = "localhost", port = 5432, c(99013, 99021))
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
setwd(rstudioapi::getActiveDocumentContext())
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
library("EML", lib.loc="C:/Users/atn893/ble/metabase-to-eml-R/packrat/lib/x86_64-w64-mingw32/3.5.2")
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
library("data.table", lib.loc="C:/Users/atn893/ble/metabase-to-eml-R/packrat/lib/x86_64-w64-mingw32/3.5.2")
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
?fread
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
# create either a dataTable or an otherEntity custom class object
# for use in the custom function dataset()
create_entity <- function(meta_list, dataset_id, entity) {
# subset tables that are entity-specific
#specific <- meta_list[c("meta", "factors", "entities")]
#info <- lapply(specific, subset,datasetid == dataset_id & entity_position == entity)
ent <- subset(meta_list[["entities"]], datasetid == dataset_id & entity_position == entity)
fact1 <- subset(meta_list[["factors"]], datasetid == dataset_id & entity_position == entity)
meta1 <- subset(meta_list[["meta"]], datasetid == dataset_id & entity_position == entity)
filename <- ent$filename
size0 <- as.character(file.size(filename))
checksum <- digest::digest(filename, algo = "md5", file = TRUE)
if (ent$entitytype == "dataTable") {
## set_physical() is a method from `eml` package
physical <- set_physical(
objectName = filename,
size = size0,
sizeUnit = "byte",
url = paste0(ent$urlpath, filename),
numHeaderLines = if (is.na(ent$headerlines))
(NULL)
else
(as.character(ent$headerlines))
,
recordDelimiter = if (is.na(ent$recorddelimiter))
(NULL)
else
(ent$recorddelimiter)
,
fieldDelimiter = if (is.na(ent$fielddlimiter))
(NULL)
else
(ent$fielddlimiter)
,
quoteCharacter = if (is.na(ent$quotecharacter))
(NULL)
else
(ent$quotecharacter)
,
attributeOrientation = "column",
authentication = checksum,
authMethod = "MD5"
)
row <- nrow(data.table::fread(filename, data.table = F, showProgress = F))
if (dim(fact1)[1] > 0) {
attributeList <- set_attributes(meta1, factors = fact1)
} else {
attributeList <- set_attributes(meta1)
}
# assemble dataTable
dataTable <- list(
entityName = ent$entityname,
entityDescription = ent$entitydescription,
physical = physical,
attributeList = attributeList,
numberOfRecords = as.character(row)
)
} else {
physical <- list(
objectName = filename,
size = list(size0, unit = "byte"),
authentication = list(checksum, method = "MD5"),
dataFormat = list(externallyDefinedFormat = list(formatName = ent$formatname)),
distribution = list(online = list(url = list(paste0(ent$urlpath, filename),
"function" = list("download"))
))
)
dataTable <- list(
entityName = ent$entityname,
entityDescription = ent$entitydescription,
physical = physical,
entityType = ent$entitytype
)
}
return(dataTable)
}
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
install.packages("data.table")
# create an entity
table_99013 <- create_entity(entity_meta, dataset_id = 99013, entity = 1)
packrat::init(options = list(external.packages = c("base64enc", "BH", "bit", "blobs", "boot", "brew", "broom", "callr", "cellranger", "class", "cli", "clipr", "clisymbols", "cluster", "codetools", "colorspace", "compiler", "covr", "crayon", "curl", "data.tree", "datasets", "dbplyr", "devtools", "diagrammeR", "digest", "downloader", "dplyr", "ellipsis", "evaluate", "fansi", "forcats", "formarR", "fs", "generics", "ggplot2", "gh", "git2r", "glue", "graphics ")))
packrat::init()
packrat::init(options = list(external.packages = c("base64enc", "BH", "bit", "blob", "boot", "brew", "broom", "callr", "cellranger", "class", "cli", "clipr", "clisymbols", "cluster", "codetools", "colorspace", "compiler", "covr", "crayon", "curl", "data.tree", "datasets", "dbplyr", "devtools", "DiagrammeR", "digest", "downloader", "dplyr", "ellipsis", "evaluate", "fansi", "forcats", "formatR", "fs", "generics", "ggplot2", "gh", "git2r", "glue", "graphics")))
packrat::init(options = list(external.packages = c("base64enc", "BH", "bit", "blob", "boot", "brew", "broom", "callr", "cellranger", "class", "cli", "clipr", "clisymbols", "cluster", "codetools", "colorspace", "compiler", "covr", "crayon", "curl", "data.tree", "datasets", "dbplyr", "devtools", "DiagrammeR", "digest", "downloader", "dplyr", "ellipsis", "evaluate", "fansi", "forcats", "formatR", "fs", "generics", "ggplot2", "gh", "git2r", "glue", "graphics")))
warnings()
