}
coverage1 <- new("Coverage",
geographicCoverage = geoall,
temporalCoverage = tempcover
)
# keyword
keyword1 <- droplevels(keyword[keyword$datasetid == datasetid, ])
nkey <- unique(keyword1$keyword_thesaurus)
for (i in 1:length(nkey)) {
if (nkey[i] == "none") {
k <- new("keywordSet", keyword = as.vector(keyword1[keyword1$keyword_thesaurus == nkey[i], "keyword"]))
} else {
k <- new("keywordSet", keyword = as.vector(keyword1[keyword1$keyword_thesaurus == nkey[i], "keyword"]), keywordThesaurus = nkey[i])
}
if (i == 1) {
kall <- list(k)
} else {
kall <- c(kall, list(k))
}
}
# the boilerplate information
sharefile <- "../00_Shared_document/"
xml_in <- read_eml(paste0(sharefile, "boilerplate.xml"), sep = "")
access1 <- eml_get(xml_in@access)
contact1 <- eml_get(xml_in@dataset, element = "contact")
distribution1 <- eml_get(xml_in@dataset, element = "distribution")
publisher1 <- eml_get(xml_in@dataset, element = "publisher")
project_xml <- eml_get(xml_in@dataset, element = "project")
intellectualrights1 <- as(set_TextType(paste0(sharefile, "IntellectualRights.docx")), "intellectualRights")
# put the dataset together
dataset1 <- new("dataset",
title = project1$title,
alternateIdentifier = project1$alternatedid,
shortName = project1$shortname,
creator = pall,
pubDate = as.character(as.Date(project1$pubdate)),
intellectualRights = intellectualrights1,
abstract = abstract,
keywordSet = kall,
coverage = coverage1,
contact = contact1,
publisher = publisher1,
distribution = distribution1,
project = project_xml,
methods = method_xml,
language = "English",
dataTable = dataTable,
otherEntity = otherentity
)
#-------------------------------------------------------------------
# unit list
unit1 <- unit[unit$datasetid == datasetid, ]
# EML
if (dim(unit1)[1] > 0) {
eml <- new("eml",
packageId = project1$edinum,
system = "knb",
schemaLocation = "eml://ecoinformatics.org/eml-2.1.1 http://nis.lternet.edu/schemas/EML/eml-2.1.1/eml.xsd",
access = access1,
dataset = dataset1,
additionalMetadata = as(set_unitList(unit1), "additionalMetadata")
)
} else {
eml <- new("eml",
packageId = project1$edinum,
system = "knb",
schemaLocation = "eml://ecoinformatics.org/eml-2.1.1 http://nis.lternet.edu/schemas/EML/eml-2.1.1/eml.xsd",
access = access1,
dataset = dataset1
)
}
return(eml)
}
datatablefun <- function(datasetid, entity) {
entities_s <- entities[entities$datasetid == datasetid & entities$entity_position == entity, ]
filename <- entities_s$filename
size0 <- as.character(file.size(filename))
checksum <- digest::digest(filename, algo = "md5", file = TRUE)
if (entities_s$entitytype == "dataTable") {
physical <- set_physical(
objectName = filename,
size = size0,
sizeUnit = "byte",
url = paste0(entities_s$urlpath, filename),
numHeaderLines = if (is.na(entities_s$headerlines)) (NULL) else (as.character(entities_s$headerlines)),
recordDelimiter = if (is.na(entities_s$recorddelimiter)) (NULL) else (entities_s$recorddelimiter),
fieldDelimiter = if (is.na(entities_s$fielddlimiter)) (NULL) else (entities_s$fielddlimiter),
quoteCharacter = if (is.na(entities_s$quotecharacter)) (NULL) else (entities_s$quotecharacter),
attributeOrientation = "column",
authentication = checksum,
authMethod = "MD5"
)
row <- nrow(fread(filename, data.table = F, showProgress = F))
meta1 <- meta[meta$datasetid == datasetid & meta$entity_position == entity, ]
fact1 <- fact[fact$datasetid == datasetid & fact$entity_position == entity, c("attributeName", "code", "definition")]
if (dim(fact1)[1] > 0) {
attributeList <- set_attributes(meta1, factors = fact1)
} else {
attributeList <- set_attributes(meta1)
}
dataTable <- new("dataTable",
entityName = entities_s$entityname,
entityDescription = entities_s$entitydescription,
physical = physical,
attributeList = attributeList,
numberOfRecords = as.character(row)
)
} else {
physical <- new("physical",
objectName = filename,
size = new("size", size0, unit = "byte"),
authentication = new("authentication", checksum, method = "MD5"),
dataFormat = new("dataFormat",
externallyDefinedFormat = new("externallyDefinedFormat",
formatName = entities_s$formatname
)
),
distribution = new("distribution", online = new("online", url = new("url",
paste0(entities_s$urlpath, filename),
"function" = new("xml_attribute", "download")
)))
)
dataTable <- new("otherEntity",
entityName = entities_s$entityname,
entityDescription = entities_s$entitydescription,
physical = physical,
entityType = entities_s$entitytype
)
}
return(dataTable)
}
# batch for all the XML generated file
library(EML)
library(rmarkdown)
library(RPostgreSQL)
library(dplyr)
library(data.table)
library(tools)
library(methods)
library(xlsx)
# loading all the packages
source("00_EMLmbon/posgre.r")
source("00_EMLmbon/datatable.r")
source("00_EMLmbon/dataset.r")
source("00_batch/user_info.r")
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
meta <- posgre$meta
fact <- posgre$fact
unit <- posgre$unit
creator <- posgre$creator
keyword <- posgre$keyword
entities <- posgre$entities
dataset <- posgre$dataset
method <- posgre$method
geo <- posgre$geo
tempo <- posgre$tempo
source("00_batch/batch_xml.R")
# _----------------------------------
# generate EML
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
datasetid <- 1001
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
otherentity1 <- datatablefun(
datasetid = datasetid,
entity = 2
)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1,
otherentity = otherentity1
)
eml_validate(eml)
write_eml(eml, "XML_1001.xml")
View(posgre)
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
?file.info
View(entities)
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
View(posgre)
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
View(posgre)
# batch for all the XML generated file
library(EML)
library(rmarkdown)
library(RPostgreSQL)
library(dplyr)
library(data.table)
library(tools)
library(methods)
library(xlsx)
# loading all the packages
source("00_EMLmbon/posgre.r")
source("00_EMLmbon/datatable.r")
source("00_EMLmbon/dataset.r")
source("00_batch/user_info.r")
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
meta <- posgre$meta
fact <- posgre$fact
unit <- posgre$unit
creator <- posgre$creator
keyword <- posgre$keyword
entities <- posgre$entities
dataset <- posgre$dataset
method <- posgre$method
geo <- posgre$geo
tempo <- posgre$tempo
View(posgre)
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
View(entities)
View(posgre)
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
View(posgre)
meta <- posgre$meta
fact <- posgre$fact
unit <- posgre$unit
creator <- posgre$creator
keyword <- posgre$keyword
entities <- posgre$entities
dataset <- posgre$dataset
method <- posgre$method
geo <- posgre$geo
tempo <- posgre$tempo
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1,
otherentity = otherentity1
)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1
)
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
meta <- posgre$meta
fact <- posgre$fact
unit <- posgre$unit
creator <- posgre$creator
keyword <- posgre$keyword
entities <- posgre$entities
dataset <- posgre$dataset
method <- posgre$method
geo <- posgre$geo
tempo <- posgre$tempo
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
meta <- posgre$meta
fact <- posgre$fact
unit <- posgre$unit
creator <- posgre$creator
keyword <- posgre$keyword
entities <- posgre$entities
dataset <- posgre$dataset
method <- posgre$method
geo <- posgre$geo
tempo <- posgre$tempo
View(creator)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1
)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1
)
View(datatable1)
View(creator)
View(creator)
View(dataset)
View(geo)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1
)
creator_s <- creator[creator$datasetid == datasetid & creator$authorshiprole == "creator", ]
for (i in 1:nrow(creator_s)) {
if (i == 1 & creator_s[i, "surname"] == "") {
p <- new("creator",
organizationName = creator_s$organization[i],
address = new("address",
deliveryPoint = if (!is.na(creator_s$address2[i])) {
paste0(creator_s$address1[i], ",", creator_s$address2[i])
} else {
creator_s$address1[i]
},
city = creator_s$city[i],
administrativeArea = creator_s$state[i],
postalCode = creator_s$zipcode[i],
country = creator_s$country[i]
),
electronicMailAddress = creator_s$email[i]
)
pall <- list(p)
}
else {
givenname <- ifelse(!is.na(creator_s$givenname2[i]), paste0(creator_s$givenname[i], " ", creator_s$givenname2[i]), creator_s$givenname[i])
p <- new("creator",
individualName = new("individualName",
givenName = givenname,
surName = creator_s$surname[i]
),
electronicMailAddress = if (is.na(creator_s$email[i])) (NULL) else (creator_s$email[i]),
userId = if (!is.na(creator_s$orcid[i])) {
new("userId", paste0("https://orcid.org/", creator_s$orcid[i]), directory = "http://orcid.org/")
} else {
NULL
}
)
pall <- c(pall, list(p))
}
}
for (i in 1:nrow(creator_s)) {
if (i == 1) {
p <- new("creator",
organizationName = creator_s$organization[i],
address = new("address",
deliveryPoint = if (!is.na(creator_s$address2[i])) {
paste0(creator_s$address1[i], ",", creator_s$address2[i])
} else {
creator_s$address1[i]
},
city = creator_s$city[i],
administrativeArea = creator_s$state[i],
postalCode = creator_s$zipcode[i],
country = creator_s$country[i]
),
electronicMailAddress = creator_s$email[i]
)
pall <- list(p)
}
else {
givenname <- ifelse(!is.na(creator_s$givenname2[i]), paste0(creator_s$givenname[i], " ", creator_s$givenname2[i]), creator_s$givenname[i])
p <- new("creator",
individualName = new("individualName",
givenName = givenname,
surName = creator_s$surname[i]
),
electronicMailAddress = if (is.na(creator_s$email[i])) (NULL) else (creator_s$email[i]),
userId = if (!is.na(creator_s$orcid[i])) {
new("userId", paste0("https://orcid.org/", creator_s$orcid[i]), directory = "http://orcid.org/")
} else {
NULL
}
)
pall <- c(pall, list(p))
}
}
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1
)
# batch for all the XML generated file
library(EML)
library(rmarkdown)
library(RPostgreSQL)
library(dplyr)
library(data.table)
library(tools)
library(methods)
library(xlsx)
# loading all the packages
source("00_EMLmbon/posgre.r")
source("00_EMLmbon/datatable.r")
source("00_EMLmbon/dataset.r")
source("00_batch/user_info.r")
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
meta <- posgre$meta
fact <- posgre$fact
unit <- posgre$unit
creator <- posgre$creator
keyword <- posgre$keyword
entities <- posgre$entities
dataset <- posgre$dataset
method <- posgre$method
geo <- posgre$geo
tempo <- posgre$tempo
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
setwd("C:/Users/atn893/Downloads/mini_metabase_three_schema")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
datasetid <- 1001
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1
)
keyword1 <- droplevels(keyword[keyword$datasetid == datasetid, ])
nkey <- unique(keyword1$keyword_thesaurus)
# input postgreSQL table
posgre <- posgrefun(
dbname = "li_tim_dump",
host = host,
user = user,
password = password
)
meta <- posgre$meta
fact <- posgre$fact
unit <- posgre$unit
creator <- posgre$creator
keyword <- posgre$keyword
entities <- posgre$entities
dataset <- posgre$dataset
method <- posgre$method
geo <- posgre$geo
tempo <- posgre$tempo
datatable1 <- datatablefun(
datasetid = datasetid,
entity = 1
)
#----------------------------------------------
# generate EML
eml <- datasetfun(
datasetid = datasetid,
dataTable = datatable1
)
sblueml_validate(eml)
write_eml(eml, "XML_1001.xml")
?source
